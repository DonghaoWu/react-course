5/25

1. network tab => disable cache

2. local machine => local router

3. http & https

4. 172.217.10.4:443 port number & socket

5. localStorage/cookie/session

6. http request => html => DOM => CSSOM

7. http protocal is stateless.

8. put => update all, patch => update partically

9. get request can make a create action by adding params in url.

10. status code is generated by a server. If no server, no status code.

11. <!DOCTYPE html> tell the browser this is a html file.

12. I18N => language, L10N => same language different country.

13. critical rendering path:[https://github.com/DonghaoWu/WebDev-tools-demo/blob/master/Performance-Part1/PP1.2-Readme.md](https://github.com/DonghaoWu/WebDev-tools-demo/blob/master/Performance-Part1/PP1.2-Readme.md)

14. css in the head, js in the body

15. - ECMAScript => syntax standard,
    - JavaScript => ECMAScript + Web API
    - Node.js => ECMAScript + NodeAPI/ServerAPI

16. inline/block/inline-block element.

17. Semantic html tag. `Better accessibility + organize code better.`
    - header
    - footer
    - form
    - artical

---

### 5/26:

1.

```css
/*  width = border*2 + content + padding*2 */

box-sizing: border-box;

/* width = content */

box-sizing: content-box;
```

2. breakpoint 调试时要注意当时浏览器的显示比例。

3. css reset

```css
* {
  margin: 0;
  padding: 0;
}
```

4. css normalization

5. - inline css: hgihest priority
   - id selector: highest priority

6. static(`default`)/ absolute(`look up until a non-static element parent`) / relative(`相对原始位置`) / sticky(`导航缩放时内容不会聚集`) / fixed(`导航缩放时内容会聚集`)

7. flex-grow/ flex-shrink

8. from `float` => `flex`

9. em/rem/%

10. media query `调试时要注意当时浏览器的显示比例。`

11. BEM naming

    - [http://getbem.com/](http://getbem.com/)

12.

---

### 5/27:

1. I would like to know more about BEM naming, like when to use ‘-’, ‘\_\_’ and ‘—’

2. - inline:
   - inline-block:
   - block:

3. css variables

4. `primitive types`:string / number/ boolean /undefined /null

5. null is object, but it is a primitive type.

6. pass by value / pass by refernce

7. compare undefined and null.

```js

```

8. Maybe TypeScript can fix the coercion.

9.

```js
let obj1 = {};
let obj2 = Object.create({});

class MyObj {
  constructor(name) {
    this.name = name;
  }
}

let obj3 = new MyObj('hello');
```

10. prototype chain

```js
let obj = { name: 'Dio' };

function foo(input) {
  //case 1
  input = { name: 'dojo' }; // create a new location

  //case 2
  input.name = 'dojo'; // pass by reference

  console.log(input);
}
foo(obj);
console.log(obj);
```

11. let / const / var

12.

- var - function scopr
- let - block scope
- const - block scope

13.

- let / const cannot be hoinsted?
- temporal dead zone: unreachable variable, only can use if it has been declaration.

14.

```js
// declaration, enable hoisting
function hello() {}

// expression, no hoisting
const hello = function () {};
// arrow, no hoisting
const hello = () => {};
```

15. class will not be hoisted.

16. construcotr function.

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

let p = new Person('hello', 10);
console.log(p);
```

---

5/28

1. 20 ppl per page.

5/31

6/1

1. Constructor function / class

2.

```js
class Person {
  #name;
  #age;

  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }
  get name() {
    return this.#name;
  }
  set name(newName) {
    this.#name = newName;
  }
  walk() {
    console.log(this.#name, this.#age);
  }
}
```

3. prototype.

```js
Person.prototype === p.__proto__;
```

4. inheritance

```js
class Person {
  #name;
  #age;
  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }
  get name() {
    return this.#name;
  }
  set name(newName) {
    this.#name = newName;
  }
  walk() {
    console.log(this.#name + ' walk around the world! ' + this.#age);
    console.log(this.#name, 'walk around the world!', this.#age);
    console.log(`${this.#name} walk around the world! ${this.#age}`);
  }
}

class Employee extends Person {
  constructor(name, age, company) {
    super(name, age);
    this.company = company;
  }
  walk() {
    console.log(name + ' instance 1 from employee class ');
  }
  walk(salary) {
    console.log(this.#name + ' instance 2 from employee class ' + salary);
  }
}

const e = new Employee('Dio', 200, 'Jump');
console.log(e);
e.walk();

function Employee(name, age, company) {
  const P = Person.bind(this);
  P(name, age); // call apply bind
  this.company = company;
}
Employee.prototype = Person.prototype;
Employee.prototype.constructor = Employee;
```

5. apply / call

6. poly-morph-ism

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  move() {
    console.log('move');
  }
}
class Fash extends Animal {
  constructor(name) {
    super(name);
  }
  move() {
    return console.log(this.name + ' can swim');
  }
}
class Bird extends Animal {
  constructor(name) {
    super(name);
  }
  move() {
    return console.log(this.name + ' can fly');
  }
}
class Monkey extends Animal {
  constructor(name) {
    super(name);
  }
  move() {
    return console.log(this.name + ' can run');
  }
}

const fish = new Fash('fish');
const bird = new Bird('bird');
const monkey = new Monkey('monkey');
fish.move();
bird.move();
monkey.move();
```

7. abstraction

```js
class Circle {
  #pi = 3.1415926;
  constructor(radius) {
    this.radius = radius;
  }

  getArea() {
    return this.#pi * this.radius ** 2;
  }
}

const c = new Circle(20);
console.log(c.getArea());
```

8.

```js
for (let i in arr) {
  console.log(arr[i]);
}

for (let el of arr) {
  console.log(el);
}
```

9. map 可以创建新数组， forEach 不能。

```js
let arr = [1, 2, 3];
arr.forEach((num, i, array) => {
  array[i] = num * 2;
});

console.log(arr);
arr.map((num, i, array) => {
  array[i] = num * 2;
});
console.log(arr);

arr = arr.map((x) => x + 2);
console.log(arr);
```

10.

```js
Array.prototype.myForEach = function () {};
```

11.

```js
const arr = [3, 2, 1];

Array.prototype.myForEach = function (callbackfn) {
  for (let i = 0; i < this.length; i++) {
    callbackfn(this[i], i, this);
  }
};

arr.myForEach((num, i, array) => {
  array[i] = num * 2;
});

console.log(arr);
```

12.

```js
Array.prototype.myMap = function (callbackfn) {
  const arr = [];
  for (let i = 0; i < this.length; i++) {
    arr.push(callbackfn(this[i], i, this));
  }
  return arr;
};
```

13.

```js
const arr = ['a', 'b', 'c'];
console.log(arr.reduce((acc, cur, i, arr) => acc + cur + cur, 'dd'));

Array.prototype.myReduce = function (callback) {};
```

14.

```js
// oop: Object-oriented programming

// // encapsulation
// class Person {
//     #name;
//     #age;
//     constructor(name, age) {
//         this.#name = name;
//         this.#age = age;
//     }
//     get name() {
//         return this.#name;
//     }
//     set name(newName) {
//         this.#name = newName;
//     }
//     walk() {
//         console.log(this.#name + ' walk around the world! ' + this.#age);
//         console.log(this.#name, 'walk around the world!', this.#age);
//         console.log(`${this.#name} walk around the world! ${this.#age}`);
//     }
// }

// function Person(name, age) {
//     this.name = name;
//     this.age = age;
// }
// Person.prototype.walk = function() {
//     console.log(this.name + ' walk around the world! ' + this.age);
// }

// const p = new Person('Jojo', 18);
// Person.prototype.__proto__.run = function() {
//     console.log(this.name + ' is running');
// }
// console.log(p);
// p.walk();
// p.run();

// console.log(Person.prototype === p.__proto__);

// const p1 = new Person('Dio', 200);
// console.log(p1);
// p1.walk();
// p1.run();
// p.name = 'Dio';
// console.log(p.name);
// p.walk();

// // // inheritance
// class Employee extends Person {
//     constructor(name, age, company) {
//         super(name, age);
//         this.company = company;
//     }
//     walk() {
//         console.log(this.name + ' instance 1 from employee class ');
//     }
//     walk(salary) {
//         console.log(this.name + ' instance 2 from employee class ' + 20000);
//     }
// }

// function Employee(name, age, company) {
//     const P = Person.bind(this);
//     P(name, age); // call apply bind
//     this.company = company;
// }
// Employee.prototype = Person.prototype;
// Employee.prototype.constructor = Employee;

// const e = new Employee('Dio', 200, 'Jump');
// console.log(e);
// e.walk();

// // Poly-morph-ism : Many Forms
// class Animal {
//     constructor(name) {
//         this.name = name;
//     }
//     move() {
//         console.log('move');
//     }
// }
// class Fash extends Animal {
//     constructor(name) {
//         super(name);
//     }
//     move() {
//         return console.log(this.name + ' can swim');
//     }
// }
// class Bird extends Animal {
//     constructor(name) {
//         super(name);
//     }
//     move() {
//         return console.log(this.name + ' can fly');
//     }
// }
// class Monkey extends Animal {
//     constructor(name) {
//         super(name);
//     }
//     move() {
//         return console.log(this.name + ' can run');
//     }
// }
// const fish = new Fash('fish');
// const bird = new Bird('bird');
// const monkey = new Monkey('monkey');
// fish.move();
// bird.move();
// monkey.move();

// // Abstraction
// class Circle {
//     #pi = 3.1415926;
//     constructor(radius) {
//         this.radius = radius;
//     }

//     getArea() {
//         return this.#pi * this.radius ** 2;
//     }
// }
// const c = new Circle(20);
// console.log(c.getArea());

// // loop

// for (let i = 0; i < arr.length; i++)
// const arr = [3, 2, 1];

// Array.prototype.myForEach = function(callbackfn) {
//     // console.log('this: ', this);
//     for (let i = 0; i < this.length; i++) {
//         callbackfn(this[i], i, this);
//     }
// }

// Array.prototype.myMap = function(callbackfn) {
//     // console.log('this: ', this);
//     const arr = [];
//     for (let i = 0; i < this.length; i++) {
//         arr.push(callbackfn(this[i], i, this));
//     }
//     return arr;
// }

// Array.prototype.myFilter = function(callbackfn) {
//     // console.log('this: ', this);
//     const arr = [];
//     for (let i = 0; i < this.length; i++) {

//         if (callbackfn(this[i], i, this)) {
//             arr.push(this[i])
//         }
//     }
//     return arr;
// }

// // mySome, myEvery, myReduce

// const arr = ['a', 'b', 'c'];
// console.log(arr.reduce((acc, cur, i, arr) => acc + cur + cur, 'dd')); // 'ddaabbcc'
// // 'dd' + a + a = 'ddaa' + b + b = ddaabb + c + c

// for (let i in arr) {
//     console.log(arr[i]);
// }

// console.log(arr.myFilter((num, i, array) => {
//     return num > 1;
// }));

// const obj = {name: 'Jojo', age: 18};

// for (let key in obj) {
//     console.log(key, obj[key]);
// }

// // object copy

// shallow copy & deep copy
```

15.

```js
// date: new Date(),
// fn: ()=>{},

const obj2 = JSON.parse(JSON.stringfy(obj));
```

16. solution: Lodash

```bash
$ npm i lodash.clonedeep
```

17.

```js
const _ = require('lodash');
const obj3 = _.cloneDeep(obj);
console.log(obj, obj3);
```

6/3:

1. closure

- It is kind of like some function private variables that you don’t want it to expose to other users.

```js
fucntion foo(){
    console.log('hello');
    var a = 5;
    return funtion(){
        console.log(a);
    }
}

let a = foo();
console.log(a);
```

2. async event

```js
console.log(1);
setTimeout(() => {
  console.log(2);
}, 1000);
console.log(3);
setTimeout(() => {
  console.log(4);
}, 0);

// block code and non-block code
function foo() {
  for (var i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i);
    }, i * 1000);
  }
}
foo();
```

- Could you explain a little bit more about the difference when use let?

```js
function foo() {
  console.log('foo');
}
function randomTimer() {
  return Math.random() * 1000;
}
function callFooWithTimer() {
  setTimeout(roo, randomTimer()); //Composition
}

function call2(cb) {
  let timer = randomTimer();
  console.log(timer);
  setTimerout(cb, timer);
}
```

2. callback hell/ api, higher order function

```js
function getUser(userID, cb) {
  let data;
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
      data = JSON.parse(this.responseText);
      cb(data);
    }
  };
  xhttp.open(
    'GET',
    'https://jsonplaceholder.typicode.com/todos/' + userID,
    true
  );
  xhttp.send();
}
getUser(1, (data1) => {
  //More logic
  logMsg(data1);
  getUser(2, (data2) => {
    logMsg(data2);
    getUser(3, (data3) => {
      logMsg(data3);
    });
  });
});

function logMsg(msg) {
  console.warn(msg);
}
```

3. destructure, declare variables

```js
let person = {
  age: 20,
  name: dio,
};

// array declaration
const { age, name } = person;

const arr = [{ name: 'dio' }, () => {}];

const [person, movement] = arr;
```

4. arrow function

```js
function foo() {
  console.log('Normal function:');
  console.log(this);
}

let foo2 = () => {
  console.log('Arrow function');
  console.log(this);
};

foo();
foo2();
```

5. binding, inpresive, expresive

```js
this.x = 9;
const myObj = {
    x:81,
    getX:function(){
        rturn this.x;
    }
};

console.log(myObj.getX());
const retriveX = myObj.getX;
console.log(retriveX());
```

```js
function foo(){
    console.log('Normal function:');
    console.log(this);
}.bind(this);

foo();

let foo2 = ()=>{
    console.log('Arrow function');
    console.log(this);
}

foo2();
```

```js
const obj = {
  foo: function () {
    console.log(this);
  },
  foo2: () => {
    console.log(this);
  },
};

obj.foo();
obj.foo2();

const obj = {
  foo: function () {
    console.log(this);
  }.bind(this),
  foo2: () => {
    console.log(this);
  },
};

obj.foo();
obj.foo2();
```

- if you use function in obj,it is better to use function declaration not arrow function.

6. IIFE

```js
(function foo() {
  console.log('hello');
})();

const controller = (function () {
  let a = 5;
  return {
    init: () => {
      console.log('init: ', a);
    },
  };
})();

controller.init();
```

7. Currying function

```js
function add(a) {
  return function (b) {
    return a + b;
  };
}

console.log(add(1)(2));

const add =
  (...a) =>
  (...b) =>
  (...c) => {
    return [...a, ...b, ...c].reduce((acc, cur) => acc + cur, 0);
  };
```

6/7:

1. Promise

```js
const p = new Promise((resolve, reject) => {
  console.log('Hello');
});

const p = new Promise((resolve, reject) => {
  let timer = randomTimer();
  setTimeout(() => {
    resolve('hello');
  })
    .then((data) => {
      logMsg(data);
    })
    .then((data) => {
      logMsg(data);
    });
});
```

- Promise 会运行 console.log，当它被定义的时候。

```js
function getUser(userID) {
  return new Promise((resolve, reject) => {
    let data;
    let xttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        data = JSON.parse(this.responseText);
        resolve(data);
      }
    };
    xhttp.open('GET', 'api' + userID, true);
    xhttp.send();
  });
}

getUser(1)
  .then((data) => {
    console.log(data);
    return getUser(2);
  })
  .then((data) => {
    console.og(data);
  });
```

- `意味着 getUser(1),然后结果是 return a promise，过程是运行 promise 的 parameter，也就是 callback function。`

2. class & promise

```js
class MyPromise {
  constructor(cb) {
    this.resolve = function () {
      const curThenCb = this.thenCbQueue.shift();
      curThenCb(data);
    };
    this.reject = function () {};
    this.thenCbQueue = [];
    cb(this.resolve, this.reject);
  }

  then(thenCb) {
    this.thenCbQueue.push(thenCb);
  }
}

const p = new MyPromise((res, rej) => {
  res('Hello');
}).then((data) => {
  console.log(data);
});
```

- I would like the purpose of this demonstration about MyPromise, I don’t get the point.

```js
// 在运行以下的代码时，cb 是直接运行的。
const p = new Promise(cb);
```

6/9:

1. promise 中的 catch 可以用来接住之前的 throw new Error，也可以用来接住 reject 中的信息，还可以接住 api 返回的 error。

2. At the beginning, ‘this’ in personIntro represent global object, after bind method in line 101, ‘this’ in personIntro change to person object.

3. bind/call/apply, simple explanation.

```js
//bind(), apply(), call()
const person = {
  firstName: 'Ana',
  lastName: 'Xin',
  getFullName: function () {
    let fullName = this.firstName + ' ' + this.lastName;
    return fullName;
  },
};

let personIntro = function (hobby, food) {
  console.log(
    this.firstName +
      ' ' +
      this.lastName +
      ' ' +
      ' loves ' +
      hobby +
      ' and ' +
      food
  );
};

let myIntro = personIntro.bind(person);
myIntro('video games', 'sushi');

personIntro.apply(person, ['painting', 'fruits']);

personIntro.call(person, 'painting', 'fruits');
```

4. fetch is an async function that return an promise.

```js
const fetch = (url) =>{
    return new promise((res, rej)=>{
        const xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function(){
            if(this.readyState == 4 && this.status == 200){
                const response = {
                    json:function(){
                        return new Promise((resolve, reject)=>{
                            resolve(JSON.parse(xhttp.responseText))
                        });
                    };
                    res(response);
                }
            }
        }
        xhttp.open('GET', url,true);
        xhttp.send();
    });
}
```

5. promise.all, to control the sequence.

```js
const promise1 = fetch('https://jsonplaceholder.typicode.com/todos/1').then(
  (response) => response.json()
);
const promise2 = fetch('https://jsonplaceholder.typicode.com/todos/2').then(
  (response) => response.json()
);
const promise3 = fetch('https://jsonplaceholder.typicode.com/todos/3').then(
  (response) => response.json()
);

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);
});
```

- Could you talk a little bit about which part is more important in the foundation session? Or which part we should focus on? BTW, I like your course.

6/9:

1. todo list

- js css html
- json placeholder
- fetch

```js

```

2. google font, copy the font link

3. font-family:

```css
:root {
  --height-header: 60px;
  --height-todolist: 300px;
  --height-todolist-header: 30px;

  --width-todolist: 400px;

  --color-green: rgb(30, 255, 0);
  --color-red-button: rgb(148, 21, 21);
  --color-red-li-hover: rgb(27, 172, 8);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Dancing Script', cursive;
}

html,
body {
  height: 100%;
  width: 100%;
  overflow: hidden;
}

.header {
  position: fixed;
  background: linear-gradient(to right, black, var(--color-green));
  height: var(--height-header);
  width: 100%;
  color: white;
  font-size: 2rem;
  text-transform: capitalize;
  line-height: var(--height-header);
  letter-spacing: 3px;
  padding-left: 10px;
  user-select: none;
}

.content {
  display: flex;
  justify-content: center;
  align-items: center;

  height: 100%;
  width: 100%;
  background-color: bisque;
}
.todolist {
  height: var(--height-todolist);
  width: var(--width-todolist);
  background-color: var(--color-green);
  box-shadow: 10px 10px 10px black;
  border-radius: 10px;
}

.todolist__header,
.todolist__input,
ul li {
  height: var(--height-todolist-header);
  width: 100%;
  outline: none;
  border: none;
  font-size: 1rem;
  text-transform: capitalize;
  line-height: var(--height-todolist-header);
  letter-spacing: 3px;
  padding-left: 10px;
  user-select: none;
  list-style: none;
}

.todolist__header {
  font-size: 1.5rem;
  text-align: center;
}

.todolist__content {
  height: calc(var(--height-todolist) - var(--height-todolist-header) * 2);
  overflow: auto;
}

ul li span {
  width: 100%;
  overflow: hidden;
}
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./index.css" />
    <script async src="./index.js"></script>
  </head>
  <body>
    <header class="header">welcome to antra</header>
    <main class="content">
      <section class="todolist">
        <header class="todolist__header">todo list</header>
        <input type="text" class="todolist__input" placeholder="input here" />
        <ul class="todolist__content">
          <li>task1</li>
          <li>task1</li>
          <li>task1</li>
        </ul>
      </section>
    </main>
  </body>
</html>
```

- better to use `NodeList`

- innerHTML
- appenChild

```js
// Model View Controller

const todoAPI = (() => {
  const baseUrl = 'https://jsonplaceholder.typicode.com';
  const todoPath = 'todos';

  const getAllTodos = () =>
    fetch([baseUrl, todoPath].join('/')).then((response) => response.json());

  return {
    getAllTodos,
  };
})();

const View = (() => {
  const domString = {
    todolist: 'todolist__content',
  };

  const render = (element, htmlString) => {
    element.innerHTML = htmlString;
  };

  const createTodoTmp = (todoArray) => {
    let htmlString = '';
    todoArray.forEach((ele) => {
      htmlString += `
                <li>
                    <span>
                        ${ele.title}
                    </span>
                </li>
            `;
    });
    return htmlString;
  };

  return {
    domString,
    render,
    createTodoTmp,
  };
})();

const Model = ((api) => {
  class Todo {
    constructor(userId, id, title, completed) {
      this.userId = userId;
      this.id = id;
      this.title = title;
      this.completed = completed;
    }
  }

  const getAllTodos = api.getAllTodos;

  return {
    getAllTodos,
    Todo,
  };
})(todoAPI);

const AppController = ((model, view) => {
  const todoElement = document.querySelector('.' + view.domString.todolist);

  const init = () => {
    model.getAllTodos().then((data) => {
      const todoTmp = view.createTodoTmp(data);
      view.render(todoElement, todoTmp);
    });
  };

  return {
    init,
  };
})(Model, View);

AppController.init();
```

6/10:

1.

6/14:

1. JQuery

2. exam:

- JQuery
- reading documentations
-

```bash
$ npm i jquery
```

- CDN, content delivery network
- CDN is also a server.
- reduce local source latency.
- reduce static file size

- Jquery script is in the head part of html.

- $ in JQuery is a function.

```js
const a = fucntion(){};
const b = function(){};

console.log(a === b);
```

- cannot define same name in the same scope twice.
- this keyword in class refers to the instance of the class.

- it is better to use class method than object function.

2. MyJQuery -- 6/14, show()/hide()/on()/ajax()

```js
class MyQuery {
  constructor(selector) {
    const el = document.querySelector(selector);
    this.el = el;
  }

  html(content) {
    this.el.innerHTML = content;
  }

  hide() {
    this.el.style.display = 'none';
  }

  show() {
    this.el.style.display = 'block';
  }

  on(event, cb) {
    this.el.addEventListener(event, cb);
  }
}

const $$ = function (selector) {
  return new MyQuery(selector);
};

$$.ajax = function ({ url, success }) {
  fetch(url)
    .then((res) => res.json())
    .then((data) => {
      success(data);
    });
};

// innerHTML method
$$('button.test').html('Next step');

//-------- event listener
let hiddenBox = $$('#banner-message');
hiddenBox.hide();

$$('#button-container button').on('click', function (event) {
  hiddenBox.show();
});

// ajax
$$.ajax({
  url: 'https://jsonplaceholder.typicode.com/todos/1',
  success: function (result) {
    console.log(result);
  },
});
```

3. index.html
   - ./Jquery/index.html

6/16:

1. fullstack application

2. mean stack, authetication.

3. todolist

4.

```js
this.el.style.visibility = 'hidden';
this.el.style.display = 'none';
```

5. for loop / forEach, forEach cannot be broke.

6.

```js
console.log([1, 2, 3].map === Array.prototype.map);
```

---

### React

1. react cdn

2. react is an object, react.Component is a class.

3. what is jsx used for?

4.

6/17:

1. dns => https request => html/json => parse html =>build the dom => build cssom =>

2. 通过 script 改变的 style 一般是提高了 priority。

3. !important > inline(or script) > internal > external

4. from jsx to js to create an element.

5. babel is for converting jsx to js.

```jsx
render(){
    return <Hello name='ty'>
};

render(){
    return React.createElement(Hello, {name:'ty'})
}
```

```js
import React from 'react';

function App() {
  return <h1>Hello World</h1>;
}

// -----
import React from 'react';

function App() {
  return React.createElement('h1', null, 'Hello world');
}
```

6.

```bash
$ npm i -g npm
$ npm init -y #default setting
$ npm i react reactdom
$ touch .gitignore
```

7. react is also need other libraries.

8. ^17.0.2 指只在 17 号大版本内。

9. 一般而言，npm i 时会先查看 package.lock.json

10. what if the version in these two files not match? So the npm will check the package-lock file first, then package.json?

11. show taylor in the browser

---

6/18:

1. check package-lock.json, not package.json

2. why we need bundle?

3. differences

```diff
+ js language
+ ecmaScript a syntax standard
+ nodeJs
```

4. what is path.

```js
const path = require('path');
console.log(path);
```

- path is from nodeJS, the code won't work in other environment(like browser).

5. path.resolve(), resolve is like join.

6. absolute path vs relative path.

7. \_\_dirname means `an variabel that tells you the absolute path of the directory containing the currently executing file.`

8. node-power workflow, react

9. 在展示里面，使用 webpack build 命令生成 bundle.js 文件，然后在 html 中直接引用 bundle.js

10. 今天的 demo 是一个新的更原始的展示，可以开一个 project：react-03。

11. 开始加入 babel

12. install babel

```bash
$ npm i --save-dev @babel/preset-react
```

13. webpack 的 build 命令会生成 dist 文件夹，babel 的 build 命令会生成 lib 文件夹。然后通过修改 webpack.config.js 文件的 entry 为 './lib/index.js'.

14. webpack loader, 实现的是 `babel-loader`，install babel-loader

15. 把 entry 改回 ‘。/src/index.js’, no babelrc `(6/18/2021, 好像仍然需要)`

16. css loader(style loader)

17. auto fix script path `plugin`

- webpackhtmlplugin

18. plugin is after bundling, and loader is before bunding.

19. [webpack documentation](https://webpack.js.org/guides/installation/#prerequisites)

---

6/21:

1. I learn something about TypeScript, do you have some advice?

2. boilerplate

3. CRA

```bash
$ npx create-react-app cra-demo
```

4. cra is a project.

5. npx runner is a template package, download into local then run, delete evently.

6. bin - command line interface

```js
"bin":{
  "create-react-app":"./index.js"
}
```

7. With plugin, the index.html in the public folder acts as a plugin template.

8. cra is using jest to test. `jest-dom`

9. package-lock can search jest.

10. `react-script start`:

11. react-script is a command line application.

12. `eject` command:

13. repotWebVitals

14. 有名字但没有值的变量，它的值是 `undefined`.

15. vitural dom cannot compare with the real dom. it is not a copy.

16. we will have two virtual dom during the work.

17. find the best way to update the real dom.

18. In react, there are two virtual dom, after comparing the difference between them, react will find a best way to update the real dom.

19. delcraletive programming: you only care about the result.

20. impairitive,

```js
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

21. document.querySelector('h1'),如果没有对象，就会返回 null。

22. 不需要 constructor。

```jsx
const list = ['a', 'b', 'c'];

class App extends Component {
  state = {
    toggle: true,
  };

  onToggleList = () => {
    this.setState((prevState) => ({
      toggle: !prevState.toggle,
    }));
  };

  render() {
    return (
      <div>
        <Toggle toggle={this.state.toggle} onToggleList={this.onToggleList} />
        {this.state.toggle && <List list={list} />}
      </div>
    );
  }
}
```

- I have a question. I see some other case, someone don't need constroctor, instead just `state = ...`, is that a good practice?

23. div vs fragment, div 就是返回一个完整实体的 div，而 fragment 则是把所有元素分散呈现，但依然作为一个整体。

24. this keyword inside a function refers to the object that call the function.

25.

```js
class A {
  state = {
    name: 'somebody',
  };
}

let a = new A();
console.log(a);
```

- 以上语句只在 node 11+ 运行，10 以下不会出错。

26. 在 CRA 中，babel 可以把一些新的语句翻译成旧 node 的语句，所以可以省略 class component 中的 constructor 和 super 语句。

27. lifecycle method, componentDidMount, componentWillUnmount, componentDidUpdate

---

6/22:

1. functional component.

```js
import { useState, Fragment, useEffect } from 'react';

const AppFc = () => {
  const [name, setName] = useState('Patrick');

  useEffect(() => {
    console.log('useEffect -- didMount.');
    return () => {
      console.log('useEffect -- WillUnmount.');
    };
  }, []);

  useEffect(() => {
    console.log('useEffect -- didUpdate.');
  }, [name]);

  const handleClick = () => {
    if (name === 'Patrick') setName('Sam');
    else setName('Patrick');
  };

  return (
    <Fragment>
      <h1>Hello {name}</h1>
      <button onClick={handleClick}>Change Name</button>
    </Fragment>
  );
};

export default AppFc;
```

2. what is state?

3. setState is an async action.

4. setState will change the state and rerender.

5. mutable & immutable

```js
let state = {
  name: 'sam',
};

// mutable, 直接改变内容
state.name = 'hello';

// imutable，复制后重新赋值，
state = {
  ...state,
  name: 'hello',
};
```

- mutable:

  - pros: easy to change, save space
  - cons: hard to track the changes, hard to track setter and getter

- imutable:

  - pros: easy store, trigger setter.
  - cons: extra space

- could you say the pros and cons again in terms of mutable and imutable? I could not catch up, my bad.

6. 可以尝试定义其他名字的 state，然后使用 setState 去改变其值。

7. mounting & rendering？

- initialize component and generate the virtual dom.

8. 3 ways to update

- new props
- setState
- forceUpdate

9. shoulComponentUpdate

10. why we need componentWillUnmount?

11. fundamental : lifecycle char.

12. mount and unmout 可以通过 另外一个 state 的 boolean 值来显示和关闭。

13. 在嵌套组件中，如果在 render 过程中出现另外一个组件，会先运行另外一个组件的 constructor，`顺序很有趣，可以下载代码验证。`

14. when is the sibling rendering? before app-didmount or after app-didmount.

15. try not to access dom before mounted.

16. fetch data after mounting finished.

17. lifecycle method order.

18. react.createElement, something props is null.

19. props

```js
let a = null;
let b = null;

console.log(a === b); // return true;
```

- parent component is updated.

-

20. props

```js
React.createElement(HelloMessage, null);
```

21. react.memo => shouldComponentUpdate

22. pureComponent

- have shouldComponentUpdate that only check for some specific changes.

- shouldComponentUpdate method and purecomponent mainly help us to reduce extra renders right? For better performance.

23. assignment

- shouldComponentUpdate
- PureComponent
- React.memo

23. shouldComponentUpdate 在什么情况下可以阻止子组件 rerender？

24. So what we are discussing now is in which case `shouldComponentUpdate` can help the subapp to prevent rerender right?

25. what if no props passing to subapp? Will it rerender when the parent update?

26. 在没有参数的子组件中，如果不想跟随父组件 rerender，只需要在 shouldComponentUpdate 中加入 return false;

27. 概念

```js
// desctruction
const [name, setName] = useState('');
```

28. 两个 useEffect

```js
React.useEffect(() => {
  console.log('didUpdate');
}, [num]);
```

29. extra render, let/useRef,

```js
const [firstCall, setFirstCall] = useState(true);
```

30.

```js
let firstCall = false;
// outside component
let firstCall = false;
```

31. useRef

```js
const firstCallRef = useRef(true);

React.useEffect(() => {
  if (firstCallRef.current === false) {
    console.log('didUpdate');
  } else {
    firstCallRef.current = false;
  }
});
```

32. I have a question, why firstCallRef.current will not back to true when the component rerender?

33. `useState 0 use once, like cloudsure, useRef the same.`

34. excution context(different from before)

- solution: global / useRef

```js

```

35. so state in class component is kind of like something global variabel in functional component?

36. create a variable to share in the function scope.

37. assignment about today, why async not make this code work?

```js
handleAdd = () => {
  this.setState({ counter: this.state.counter + 1 });
  this.setState({ counter: this.state.counter + 1 });
};
```

---

6/23:

1. class component, industry

2. functional component (new feature)

3. example

```js
let state = {
  counter:0;
}

function setState(newState){
  state = newState;
}

setState({counter: state.counter + 1});

setState({counter: state.counter + 1});

console.log(state);
```

4. setState is an async function.

5. 例子

```js
let state = {
  counter: 0,
};

function setState(newState) {
  setTimeout(() => {
    state = newState;
  }, 0);
}

setState({ counter: state.counter + 1 });

setState({ counter: state.counter + 1 });

// in the second async function counter is still 0;

setTimeout(() => {
  console.log(state);
}, 1000);
```

```js
let state = 0;

function setState(newState) {
  setTimeout(() => {
    state = newState;
  }, 0);
}

setState(state + 1);

setState(state + 1);

// 因为还没有执行，所以都是取 state = 1；
setTimeout(() => {
  console.log(state);
}, 1000);
```

6. why this work

```js
// setState((prevState)=>{

// })

function setState(newState) {
  setTimeout(() => {
    if (typeof newState === 'function') {
      state = newState(state);
    } else {
      state = newState;
    }
  }, 0);
}

setState((prevState) => {
  return {
    counter: state.counter + 1,
  };
});

setState((prevState) => {
  return {
    counter: state.counter + 1,
  };
});

console.log(state);
```

7. Layout

```js
import Reeact, { Component } from 'react';
import Header from '../Header';

class Layout extends Component {
  render() {
    const { children } = this.props;
    return (
      <>
        <header className="header">
          <Header />
        </header>
        <main className="content">{children}</main>;
      </>
    );
  }
}

export default Layout;
```

8. Header

```js
import Reeact, { Component } from 'react';

class Header extends Component {
  render() {
    return <header>Header</header>;
  }
}

export default Layout;
```

```js
function App() {
  return (
    <Layout>
      <TodoList />
    </Layout>
  );
}
```

9. index.css

```css
/* css reset */
html,
body {
  height: 100%;
  width: 100%;
}
```

10. Layout.css

```css
.header {
  position: fixed;
}

.content {
  padding-top: ;
  height: 100%;
}
```

11. TodoList.js

```js
import Reeact, { Component } from 'react';
import TodoItem from '';

class TodoList extends Component {
  render() {
    return (
      <div>
        <section className="todolist">
          <header className="todolist__header">
            <h4 className="heading">todolist</h4>
          </header>
        </section>
        <input className="todolist__input" />
        <ul className="todolist__content">
          {this.state.todolist.map((todo, index) => {
            return <TodoItem key={index} todo={todo} />;
          })}
        </ul>
      </div>
    );
  }
}

export default TodoList;
```

12. TodoItem.js

```js

```

13. function is about clean.

14. native html component. Use capital for your own component.

15. hoc |

16. sync 跟 async 不同的行为表现：

- sync：

```js
let state = 0;

function setState(newState) {
  state = newState;
}

setState(state + 1);

setState(state + 1);

setTimeout(() => {
  console.log(state);
}, 1000);
```

- async:

```js
let state = 0;

function setState(newState) {
  setTimeout(() => {
    state = newState;
  }, 0);
}

setState(state + 1);

setState(state + 1);

setTimeout(() => {
  console.log(state);
}, 1000);
```

- `区别在于 setState 的定义，一个是 sync 函数，另外一个是 async 函数。`

---

6/24:

1. exam tomorrow, if continue.

2. hoc

3. render props

4. redux

5. react-router

6. open-source

7. material ui

8. todoList

```js

```

9. onChange & onClick 都是 react 定制提供的。

10. 一般情况下，普通的表格，如果你输入内容，都默认出现内容，但在 react 中，通过以下设定：

```js
this.state={
  input:'',
}

value={this.state.input};
onChange={this.handleChange};

handleChange = ()=>{
  setState({input:event.target.value})
}

handelKeyUp = (event)=>{
  if(event.key === 'Enter'){
    const useId = 1;
    const title = this.state.input;
    const completed = false;
    const newTodo = new Todo(useId, title, completed, )

    addTodo(newTodo).then((data)=>{
      this.setState({
        todolist:[data,...this.state.todolist],
        input:''
      })
    })
  }
}
```

11. height:100%

12. conditional renderling

---

6/25:

1. Exam day: 23，react-exam-1

2. button - black - hover

---

6/26

1. 19

2. css reset

3. sementic html

- article/ session

4. assume we are fetching data, add loading logo.

5. assignment

```js
function getCards() {
  return new Promise((resolve, reject) => {
    setTImeout(() => {
      res(cards);
    }, 2000);
  });
}
```

6. high order component

```jsx
let countent = <DashBoard />;

<Layout>{content}</Layout>;
```

7. class state

```jsx
class App extends Component {
  state = {
    actionPage: 'TodoList',
  };

  handleChange = (newActivePage) => {
    this.setState({
      activepage: newActivePage,
    });
  };

  render() {
    let content = null;
    switch (state.activePage) {
      case 'Dashboard':
        content = <Dashboard />;
        break;
      case 'Todolist':
        content = <Todolist />;
        break;
      default:
        break;
    }

    return <Layout>{content}</Layout>;
  }
}
```

- 使用 state 来控制显示哪一个 component。
- 这个用法就会失去了 url 的变化。
- react-router
- why should we use url
- 22 => 20，6/28，第六周开始。
- use url to store some data
- location key / history key
- redux
- contextAPI

- hoc, 解决公用 fetch data 的问题。
- hoc 类似套壳

- withTodos.js

```js
import React from 'react';

const withTodos = (WrappedComponent) => {
  return class NewComponnet extends Component {
    state = {
      todolist: [],
    };
    componentDidMount() {
      getAllTodos().then((data) => {
        this.setState({ todolist: data });
      });
    }
    render() {
      return <WrappedComponent todolist={this.state.data} />;
    }
  };
};

withTodos(Dashboard);
```

- 但是一些本地的方法因为无法接触 state 从而无法使用，所以要把所有跟 state 相关的 method 全部放进 HOC 之中，这样就有 context API 的感觉了。

---

6/29:

- render props

1. I have a question. I have a feeling that HOC is kind of a customize contextAPI or Redux, all of them are putting state or method into one place, then pass them down to child component, is that correct?

2. render props, somthing like hoc

```jsx
import whithTodosData from '../';

class RenderPropsTest extends React.Component {
  render() {
    return <WithTodosData render={<h1>Hello</h1>}></WithTodosData>;
  }
}

class WithTodosData extends Componet {
  render() {
    const { render } = this.props;

    console.log(render);

    return render;
  }
}

class RenderPropsTest extends React.Component {
  state = {
    title: 'todoData',
  };

  render() {
    return (
      <WithTodosData
        render={<Title title="Hello world"></Title>}
      ></WithTodosData>
    );
  }
}
```

```jsx
class RenderPropsTest extends React.Component {
  render() {
    return (
      <WithTodosData
        render={(title) => <Title title={title}></Title>}
      ></WithTodosData>
    );
  }
}

class WithTodosData extends Componet {
  render() {
    state = {
      data: 'todoData',
    };
    const { render } = this.props;

    console.log(render);

    return render(this.state.data);
  }
}
```

- 可以传递参数
- 也可以传递 component + params
- 也可以是一个返回 component 的函数
- 提供一个函数/壳，让子组件自行选择自己的函数。
- 这种方法需要在 withTodosData 组件中定义 data
- 类似 HOC，
- 在 withTodosData 中加入 switch，根据具体情况向子组件传递参数/function

- redux

- number about total count

- 公用一个 render props 的 parent，不同的 parent 是不共用一个 state 的，也就是说，数据不共用，不会引起其他 component 的 rerender

- 6/29 `微信群讨论：一个冷门的观点：如果使用在 useEffect 中 fetch 外部数据，要加上 []，否则会无限 render，如果使用的是本地数据，可以不加上 []，不过总的来说最好都是加上 [] 最保险。`

---

6/30:

1. redux.

2. hoc

3. customize hooks?

4. Redux folder

- React
- Vue
- Angular

- basic redux

```bash
$ npm install redux
$
```

```diff
+
+
+
+
```

- pure function: no side effects, same input same output, data is imutable

```js
// side effect
const foo = (num) => {
  return foo2(num);
};

// pure function
const foo2 = (num) => {
  return num;
};
```

```js
// mutating the object
const foo = (obj) => {
  obj.name = 'tom';
  return obj;
};
```

- first level copy is not enough, but it is fine.

- Why reducer should be a pure function?

```js
console.log(store.getState());
```

```js
store.subscribe();
```

- subscripe is checking every dispatch.

- subscribe behave like a sync function / addEventListener.

-

```js
function myCreateStore(reducer) {
  let state;
  let listener = [];
  state = reducer(state, { type: 'init' });

  function getState() {
    return state;
  }

  function subscribe(cb) {
    listener.push(cb);
  }

  function dispatch(action) {
    state = reducer(state, action);
    listener.forEach((cb) => {
      cb();
    });
  }

  return {
    getState,
    subscribe,
    dispatch,
  };
}
```

- 先运行 subscribe， 后运行 dispatch。

- subscribe is trying to store some function, once find some dispatch,

- observer problem

-

```jsx
import React, { Component } from 'react';
import myStore from '';

class Counter extends Component {
  componentDidMount() {
    myStore.subscribe(() => this.forceUpdate());
  }
  handleAdd = () => {
    myStore.dispatch({ type: 'counter/incremented' });
  };

  handleAdd = () => {
    myStore.dispatch({ type: 'counter/decremented' });
  };

  render() {
    return (
      <div>
        <h1>Counter:{myStore.getState().value}</h1>
        <button onClick={this.handleAdd}></button>
      </div>
    );
  }
}
```

```jsx
import React, {useState} from 'react';
import myStore from '';

const useForceUpdate = ()=>{
    const [update, setUpdate] = useState('');
    return ()=>setUpdate(!update)
}

const FcCounter=()=>{
  const [add, setAdd] = useState('');

  const forUpdate = useForceUpdate();

  useEffect(()=>{
    myStore.subscribe(()=>{
      forceUpdate();
    })
  },[])

  const = handleAdd = () => {
    setAdd(add + 'd');
    forUpdate()
    myStore.dispatch({ type: 'counter/incremented' });
  };

  const = handleAdd = () => {
    setAdd(add + 'd')
    forUpdate()
    myStore.dispatch({ type: 'counter/decremented' });
  };

    return (
      <div>
        <h1>Counter:{myStore.getState().value}</h1>
        <button onClick={this.handleAdd}></button>
      </div>
    );
}
```

- customize hooks

- 6/30:

- `在 useEffect 中增加什么很讲究，正如 redux-01 project 里面的 Counter 例子，可以探究一下`

- 一个 functional component 里面的 state 改变会导致什么代码执行？

- 7/1

1. 3 ways to rerender(class): forceUpdate, state, props

2. rerender 时有些语句会重执行，有些不会

3. you can put forceUpdate into the useEffect [], or use the function way to setUpdate.

4. but in this way, we will add more and more functions into the listener, which is not good.

5. Another way is using something global, like useRef or global variabel.

```js
// way 1
let ref = 0;
ref = ref + 1;

// way 2
const ref = useRef(updateRef);

ref.current = ref.current + 1;
setUpdate(ref.current);

// way3
setUpdate(Math.random());

// way4
// redux
```

6. redux

```js
const ReactReduxTest = () => {
  return (
    <div>
      <Counter1 />
      <Counter2 />
    </div>
  );
};
```

7. react-redux

```bash
$ npm i react-redux
```

- Provider

```jsx
<Provider store={myStore}></Provider>
```

8. connect method

- connect is a function, mapStateToProps is a func, mapDispatchToProps is a func.

- connect 可以顺着 Provider 找到 store state。

```js
function mapStateToProps(state) {
  return {
    counter: state.value,
  };
}
```

- mapDispatchToProps

```js
function mapDispatchToProps(dispatch) {
  return {
    handleAdd: () => dispatch(handleAdd()),
    handleSub: () => dispatch(handleSub()),
  };
}
```

```js
import React, { Component } from 'react';
const MyReactReduxContext = React.createContext({});

export class MyProvider extends Component {
  render() {
    return (
      <MyReactReduxContext.Provider value={this.props.store}>
        {this.props.children}
      </MyReactReduxContext.Provider>
    );
  }
}

export function myConnect(mapStateToProps, mapDispatchToProps) {
  return function (WrappedComponent) {
    return class NewCompnnent extends Component {
      static contextType = MyReactReduxContext;

      componentDidMount() {
        const { subscribe } = this.context;
        subscribe(() => this.forceUpdate());
      }
      render() {
        const { getState, dispatch } = this.context;
        const msp = mapStateToProps(getState());
        const mdp = mapDispatchToProps(dispatch);

        return <WrappedComponent {...this.props} {...msp} {...mdp} />;
      }
    };
  };
}
```

- contextAPI

- build your own react-redux

- hoc `this.props`

- create useSelector/useDispatch
